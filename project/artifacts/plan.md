# Project Plan: LinkedIn Engagement Assistant

**Version:** 1.0
**Date:** 2024-07-20
**Generated By:** GPT-4o

## 1. Project Overview

*   **Goal:** To develop an intelligent browser extension that automates and scales a user's engagement on LinkedIn by intelligently liking, replying to, and messaging commenters on a given post, using AI to generate human-like, personalized content.
*   **High-Level Requirements Summary:**
    *   Develop a Manifest V3 compliant browser extension for Chromium browsers.
    *   Inject a modern, pinned sidebar UI into LinkedIn post pages for real-time control and monitoring.
    *   Automatically scroll to load all comments on a post.
    *   Parse and extract comment data, identifying the user's own comments and top-level comments without replies.
    *   Integrate with the OpenRouter API to generate AI-powered replies and direct messages.
    *   Automate a sequential pipeline of actions (Like -> Reply -> DM) with human-like, configurable delays.
    *   Persist per-post state to local browser storage to enable recovery and resume functionality.
    *   Provide a comprehensive settings panel for configuring AI models, prompts, delays, and safety limits.
    *   Display live counters, a detailed pipeline progress view, and a filterable logging panel in the UI.
*   **Key Assumptions:**
    *   The user has an active, authenticated session on LinkedIn.
    *   The user will provide a valid API key for the OpenRouter service.
    *   The extension will be developed in English.
    *   LinkedIn's front-end DOM structure and key API endpoints are relatively stable, but selectors will be centralized for maintainability.
    *   The user accepts the risks associated with using automation tools on social media platforms.

## 2. Core Architecture

*   **Architectural Style:** Client-Side, Event-Driven Architecture. The extension is self-contained within the browser, with components communicating asynchronously via messages.
*   **Technology Stack:**
    *   Frontend: Preact with TypeScript, Zustand (for state management).
    *   Backend: TypeScript in a Manifest V3 Service Worker.
    *   Database: `chrome.storage.local` for per-post state, `chrome.storage.sync` for user settings.
    *   Messaging/Queues: `chrome.runtime` and `chrome.tabs` messaging APIs.
    *   Deployment: Packaged extension for the Chrome Web Store.
    *   Other Key Libraries/Tools: Vite (build tool), ESLint, Prettier, DOMPurify (security).
*   **Key Components/Services:**
    *   **Sidebar UI (Content Script):** The user-facing Preact application, injected via Shadow DOM, for all controls and monitoring.
    *   **DOM Interactor (Content Script):** A module responsible for all direct DOM manipulation (scrolling, parsing, clicking, typing).
    *   **Orchestration Service (Service Worker):** The core background process managing the state machine, processing pipeline, API calls, and persistence. *A detailed Component Diagram is planned (see I1.T4)*.
    *   **Browser Storage:** Manages reading and writing state and configuration to the Chrome Storage API.
*   **Data Model Overview:** The primary data structure is a JSON object stored per-post, keyed by the post URN. It contains post metadata and an array of comment objects, each with its own state (likeStatus, replyStatus, etc.). *An ERD-style diagram is planned (see I1.T5)*.
*   **API Contract Style:** The system consumes an external RESTful API (OpenRouter's OpenAI-compatible endpoint). Internal communication is asynchronous messaging.
*   **Communication Patterns:** The Sidebar UI, DOM Interactor, and Orchestration Service communicate via a message-passing pattern using `chrome.runtime.sendMessage`. *A core interaction flow will be visualized in a Sequence Diagram (see I2.T4)*.

## 2.1. Key Architectural Artifacts Planned

*   **System Context Diagram (PlantUML):** To show the extension's high-level interactions with the user, LinkedIn, and OpenRouter. (Created in I1.T3)
*   **Container Diagram (PlantUML):** To break down the extension into its major logical components (UI, DOM Interactor, Orchestrator). (Created in I1.T4)
*   **Data Schema ERD (PlantUML):** To visualize the structure of the per-post state JSON object. (Created in I1.T5)
*   **Core Interaction Sequence Diagram (PlantUML):** To illustrate the message flow for the primary user action of starting the processing pipeline. (Created in I2.T4)
*   **AI Configuration JSON Schema (JSON Schema):** To formally define the structure of the `aiConfig` object stored in `chrome.storage.sync`. (Created in I5.T1)

## 3. Directory Structure

*   **Root Directory:** `linkedin-engagement-assistant/`
*   **Structure Definition:**
    ~~~
    linkedin-engagement-assistant/
    ├── public/
    │   ├── icons/
    │   │   ├── icon-16.png
    │   │   └── icon-48.png
    │   └── manifest.json
    ├── src/
    │   ├── background/             # Orchestration Service (Service Worker)
    │   │   ├── index.ts
    │   │   ├── services/
    │   │   │   ├── pipelineManager.ts
    │   │   │   ├── stateManager.ts
    │   │   │   ├── configManager.ts
    │   │   │   └── openRouterClient.ts
    │   │   └── logger.ts
    │   ├── content-scripts/        # DOM Interactor & UI Injection
    │   │   ├── index.ts
    │   │   └── domInteractor.ts
    │   ├── ui/                     # Sidebar UI (Preact App)
    │   │   ├── index.tsx
    │   │   ├── App.tsx
    │   │   ├── components/
    │   │   └── store/
    │   └── shared/                 # Shared code, types, and constants
    │       ├── types.ts
    │       └── constants.ts
    ├── tests/
    │   ├── unit/
    │   └── component/
    ├── docs/
    │   ├── diagrams/               # PlantUML source files for all diagrams
    │   └── schemas/                # JSON Schema files
    ├── .eslintrc.cjs
    ├── .prettierrc
    ├── package.json
    ├── tsconfig.json
    ├── vite.config.ts
    └── README.md
    ~~~

## 4. Iteration Plan

*   **Total Iterations Planned:** 8
*   **Iteration Dependencies:** Iterations are designed to be sequential, as each builds upon the foundation of the previous one.

---

### Iteration 1: Project Setup & Foundational Architecture

*   **Iteration ID:** `I1`
*   **Goal:** Initialize the project structure, build system, and generate core architectural diagrams that will guide development.
*   **Prerequisites:** None
*   **Tasks:**
    *   **Task 1.1:**
        *   **Task ID:** `I1.T1`
        *   **Description:** Initialize a new project using Vite with the Preact + TypeScript template. Configure ESLint, Prettier, and set up basic project scripts in `package.json`.
        *   **Agent Type Hint:** `SetupAgent`
        *   **Inputs:** Section 2 & 3 of this plan.
        *   **Input Files**: (Array of Strings) []
        *   **Target Files:** [`package.json`, `vite.config.ts`, `tsconfig.json`, `.eslintrc.cjs`, `.prettierrc`]
        *   **Deliverables:** A runnable, empty Vite project structure.
        *   **Acceptance Criteria:** The `npm run dev` command successfully starts the development server, and `npm run build` creates a `dist/` directory.
        *   **Dependencies:** None
        *   **Parallelizable:** Yes
    *   **Task 1.2:**
        *   **Task ID:** `I1.T2`
        *   **Description:** Create the initial `public/manifest.json` for a Manifest V3 extension. Define basic properties like name, version, permissions (`storage`, `activeTab`), and declare the service worker and content script entry points. Create empty placeholder files for them.
        *   **Agent Type Hint:** `SetupAgent`
        *   **Inputs:** Section 3 of this plan.
        *   **Input Files**: (Array of Strings) []
        *   **Target Files:** [`public/manifest.json`, `src/background/index.ts`, `src/content-scripts/index.ts`]
        *   **Deliverables:** A valid `manifest.json` file and corresponding empty script files.
        *   **Acceptance Criteria:** The generated extension can be loaded into a Chromium browser without manifest errors.
        *   **Dependencies:** `I1.T1`
        *   **Parallelizable:** No
    *   **Task 1.3:**
        *   **Task ID:** `I1.T3`
        *   **Description:** Generate the System Context Diagram in PlantUML format based on the description in the architecture document.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Section 3.3 of the architecture document.
        *   **Input Files**: (Array of Strings) []
        *   **Target Files:** [`docs/diagrams/system_context.puml`]
        *   **Deliverables:** A PlantUML file for the System Context Diagram.
        *   **Acceptance Criteria:** The PlantUML file renders correctly and accurately reflects the system's external interactions.
        *   **Dependencies:** None
        *   **Parallelizable:** Yes
    *   **Task 1.4:**
        *   **Task ID:** `I1.T4`
        *   **Description:** Generate the Container Diagram in PlantUML format based on the description in the architecture document.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Section 3.4 of the architecture document.
        *   **Input Files**: (Array of Strings) []
        *   **Target Files:** [`docs/diagrams/container.puml`]
        *   **Deliverables:** A PlantUML file for the Container Diagram.
        *   **Acceptance Criteria:** The PlantUML file renders correctly and accurately shows the major components of the extension.
        *   **Dependencies:** None
        *   **Parallelizable:** Yes
    *   **Task 1.5:**
        *   **Task ID:** `I1.T5`
        *   **Description:** Generate the Data Schema ERD in PlantUML format based on the JSON schema described in the requirements and architecture documents.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Section 5 of the requirements, Section 3.6 of the architecture document.
        *   **Input Files**: (Array of Strings) []
        *   **Target Files:** [`docs/diagrams/data_schema_erd.puml`]
        *   **Deliverables:** A PlantUML file representing the data model.
        *   **Acceptance Criteria:** The PlantUML file renders correctly and accurately reflects the per-post JSON data structure.
        *   **Dependencies:** None
        *   **Parallelizable:** Yes
    *   **Task 1.6:**
        *   **Task ID:** `I1.T6`
        *   **Description:** Create the initial `src/shared/types.ts` file. Define TypeScript interfaces for the core data models (`PostState`, `Comment`, `AIConfig`) based on the data schema from `I1.T5` and the requirements.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Deliverable from `I1.T5`, Section 14.3 of requirements.
        *   **Input Files**: (Array of Strings) [`docs/diagrams/data_schema_erd.puml`]
        *   **Target Files:** [`src/shared/types.ts`]
        *   **Deliverables:** A TypeScript file with core type definitions.
        *   **Acceptance Criteria:** Interfaces are defined for all key entities and match the specified schemas. The file has no TypeScript errors.
        *   **Dependencies:** `I1.T5`
        *   **Parallelizable:** No

---

### Iteration 2: Sidebar UI Shell & Communication Backbone

*   **Iteration ID:** `I2`
*   **Goal:** Inject a basic, non-functional sidebar UI onto LinkedIn pages and establish the fundamental message-passing communication between the UI, content script, and service worker.
*   **Prerequisites:** `I1`
*   **Tasks:**
    *   **Task 2.1:**
        *   **Task ID:** `I2.T1`
        *   **Description:** Implement the content script logic in `src/content-scripts/index.ts` to create a root element and inject the Preact Sidebar UI into the LinkedIn page using a Shadow DOM to prevent style conflicts.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 3.2 of the architecture document.
        *   **Input Files**: (Array of Strings) [`src/content-scripts/index.ts`, `src/ui/index.tsx`]
        *   **Target Files:** [`src/content-scripts/index.ts`]
        *   **Deliverables:** Code that successfully injects the UI onto the page.
        *   **Acceptance Criteria:** When on a `linkedin.com` page, a placeholder sidebar element appears.
        *   **Dependencies:** `I1.T2`
        *   **Parallelizable:** No
    *   **Task 2.2:**
        *   **Task ID:** `I2.T2`
        *   **Description:** Create the basic component structure for the Sidebar UI in Preact. Develop placeholder components for Header, Live Counters, Pipeline Progress, Controls, and Logs panels as described in the requirements.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 0 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/ui/`]
        *   **Target Files:** [`src/ui/App.tsx`, `src/ui/components/Header.tsx`, `src/ui/components/Counters.tsx`, etc.]
        *   **Deliverables:** A set of Preact components forming the UI shell.
        *   **Acceptance Criteria:** The sidebar UI renders with all planned sections visible, containing static placeholder content.
        *   **Dependencies:** `I1.T1`
        *   **Parallelizable:** Yes
    *   **Task 2.3:**
        *   **Task ID:** `I2.T3`
        *   **Description:** Set up a basic message router in the service worker (`background/index.ts`) and establish a two-way communication channel. The UI should be able to send a "ping" message and the service worker should respond with a "pong" that the UI logs to the console.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Chrome Extension messaging documentation.
        *   **Input Files**: (Array of Strings) [`src/background/index.ts`, `src/ui/App.tsx`]
        *   **Target Files:** [`src/background/index.ts`, `src/ui/App.tsx`]
        *   **Deliverables:** Code demonstrating basic message passing.
        *   **Acceptance Criteria:** The UI successfully sends a message to the service worker on load, and the service worker's response is visible in the browser console.
        *   **Dependencies:** `I2.T1`, `I2.T2`
        *   **Parallelizable:** No
    *   **Task 2.4:**
        *   **Task ID:** `I2.T4`
        *   **Description:** Generate the Core Interaction Sequence Diagram in PlantUML, illustrating the message flow for starting the pipeline, as described in the architecture document.
        *   **Agent Type Hint:** `DiagrammingAgent`
        *   **Inputs:** Section 3.7 of the architecture document.
        *   **Input Files**: (Array of Strings) []
        *   **Target Files:** [`docs/diagrams/sequence_start_pipeline.puml`]
        *   **Deliverables:** A PlantUML file for the sequence diagram.
        *   **Acceptance Criteria:** The diagram renders correctly and accurately reflects the planned asynchronous communication pattern.
        *   **Dependencies:** None
        *   **Parallelizable:** Yes

---

### Iteration 3: DOM Parsing & Data Extraction

*   **Iteration ID:** `I3`
*   **Goal:** Implement the logic to read and parse all necessary data from the LinkedIn page, without taking any automated actions.
*   **Prerequisites:** `I2`
*   **Tasks:**
    *   **Task 3.1:**
        *   **Task ID:** `I3.T1`
        *   **Description:** Implement the auto-scrolling logic in the `domInteractor.ts`. The function should repeatedly scroll the page down until the page height stabilizes, ensuring all comments are loaded.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 1 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/content-scripts/domInteractor.ts`]
        *   **Target Files:** [`src/content-scripts/domInteractor.ts`]
        *   **Deliverables:** An async function that handles page scrolling.
        *   **Acceptance Criteria:** The function reliably scrolls to the bottom of a LinkedIn post's comment section.
        *   **Dependencies:** `I2.T1`
        *   **Parallelizable:** No
    *   **Task 3.2:**
        *   **Task ID:** `I3.T2`
        *   **Description:** Implement functions in `domInteractor.ts` to parse the DOM and extract: 1) The signed-in user's profile URL. 2) All comment elements, extracting owner URL, text, and timestamp for each.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Sections 2 & 3 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/content-scripts/domInteractor.ts`]
        *   **Target Files:** [`src/content-scripts/domInteractor.ts`]
        *   **Deliverables:** Functions that return structured data parsed from the DOM.
        *   **Acceptance Criteria:** The functions accurately extract the required data from a sample LinkedIn post page.
        *   **Dependencies:** `I3.T1`
        *   **Parallelizable:** No
    *   **Task 3.3:**
        *   **Task ID:** `I3.T3`
        *   **Description:** Implement logic in the service worker that, upon receiving the parsed data from the content script, calculates the required counts: total top-level comments without replies, and user's top-level comments without replies.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 4 of the requirements, `I3.T2` deliverables.
        *   **Input Files**: (Array of Strings) [`src/background/index.ts`, `src/shared/types.ts`]
        *   **Target Files:** [`src/background/services/stateManager.ts`]
        *   **Deliverables:** Logic to process comment data and compute statistics.
        *   **Acceptance Criteria:** Given a sample comment list, the logic correctly calculates and logs the counts.
        *   **Dependencies:** `I1.T6`, `I3.T2`
        *   **Parallelizable:** No

---

### Iteration 4: State Persistence & UI Data Binding

*   **Iteration ID:** `I4`
*   **Goal:** Persist the extracted post and comment data to `chrome.storage.local` and display the live counts in the sidebar UI.
*   **Prerequisites:** `I3`
*   **Tasks:**
    *   **Task 4.1:**
        *   **Task ID:** `I4.T1`
        *   **Description:** Implement the `StateManager` in the service worker. It should handle saving the full post state (including all comments) to `chrome.storage.local` in a JSON file named by the post URN. It should also handle loading this state on startup.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 5 of the requirements, `I1.T5` diagram.
        *   **Input Files**: (Array of Strings) [`src/background/services/stateManager.ts`, `src/shared/types.ts`]
        *   **Target Files:** [`src/background/services/stateManager.ts`]
        *   **Deliverables:** A module for saving and loading state from browser storage.
        *   **Acceptance Criteria:** After parsing a post, a correctly formatted JSON object is saved to `chrome.storage.local`. Reloading the extension correctly loads this data back into memory.
        *   **Dependencies:** `I3.T3`
        *   **Parallelizable:** No
    *   **Task 4.2:**
        *   **Task ID:** `I4.T2`
        *   **Description:** Implement the UI state management using Zustand. The service worker will broadcast `STATE_UPDATE` messages with the latest counts and pipeline status. The UI store will listen for these messages and update its state, causing the Preact components to re-render.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** `I3.T3` logic, `I2.T2` components.
        *   **Input Files**: (Array of Strings) [`src/ui/store/index.ts`, `src/ui/components/Counters.tsx`, `src/background/index.ts`]
        *   **Target Files:** [`src/ui/store/index.ts`, `src/ui/components/Counters.tsx`]
        *   **Deliverables:** A reactive UI that updates when the service worker sends new data.
        *   **Acceptance Criteria:** The "Live Counters" section in the sidebar accurately reflects the counts calculated by the service worker in real-time.
        *   **Dependencies:** `I4.T1`
        *   **Parallelizable:** No
    *   **Task 4.3:**
        *   **Task ID:** `I4.T3`
        *   **Description:** Implement the "Export JSON" button in the UI. When clicked, it should request the current post's state from the service worker, which then provides the JSON data for the UI to trigger a file download.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 0 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/ui/components/Controls.tsx`, `src/background/index.ts`]
        *   **Target Files:** [`src/ui/components/Controls.tsx`]
        *   **Deliverables:** A working "Export JSON" button.
        *   **Acceptance Criteria:** Clicking the button successfully downloads a JSON file containing the full state for the current post.
        *   **Dependencies:** `I4.T1`
        *   **Parallelizable:** No

---

### Iteration 5: AI Configuration & OpenRouter Integration

*   **Iteration ID:** `I5`
*   **Goal:** Build the AI settings UI and establish a connection with the OpenRouter API to fetch models and test the API key.
*   **Prerequisites:** `I4`
*   **Tasks:**
    *   **Task 5.1:**
        *   **Task ID:** `I5.T1`
        *   **Description:** Build the "AI" section of the Controls panel in the UI. Include a masked input for the API key, a searchable combobox for models, input fields for prompts, and sliders for temperature/top-p. Also, create a formal JSON Schema for the `aiConfig` object.
        *   **Agent Type Hint:** `FrontendAgent`, `DocumentationAgent`
        *   **Inputs:** Section 14.2 and 14.3 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/ui/components/Controls.tsx`]
        *   **Target Files:** [`src/ui/components/AiSettings.tsx`, `docs/schemas/aiConfig.schema.json`]
        *   **Deliverables:** A Preact component for AI settings and a JSON Schema file.
        *   **Acceptance Criteria:** The UI for AI configuration is rendered correctly. The JSON Schema validates against the structure defined in the requirements.
        *   **Dependencies:** `I2.T2`
        *   **Parallelizable:** Yes
    *   **Task 5.2:**
        *   **Task ID:** `I5.T2`
        *   **Description:** Implement the `ConfigManager` in the service worker to save the `aiConfig` object to `chrome.storage.sync` and load it on startup. Changes in the UI should trigger messages to update the configuration.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** `I5.T1` deliverables.
        *   **Input Files**: (Array of Strings) [`src/background/services/configManager.ts`, `src/shared/types.ts`]
        *   **Target Files:** [`src/background/services/configManager.ts`]
        *   **Deliverables:** A module for managing synced configuration.
        *   **Acceptance Criteria:** AI settings persist across browser sessions and are synced between devices (if enabled).
        *   **Dependencies:** `I5.T1`
        *   **Parallelizable:** No
    *   **Task 5.3:**
        *   **Task ID:** `I5.T3`
        *   **Description:** Implement the `OpenRouterClient` in the service worker. This module will encapsulate all API calls to OpenRouter, including adding the necessary `Authorization` header with the API key from the `ConfigManager`.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 14.1 and 15 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/openRouterClient.ts`]
        *   **Target Files:** [`src/background/services/openRouterClient.ts`]
        *   **Deliverables:** A client module for interacting with the OpenRouter API.
        *   **Acceptance Criteria:** The module is created and can be instantiated with the API key.
        *   **Dependencies:** `I5.T2`
        *   **Parallelizable:** No
    *   **Task 5.4:**
        *   **Task ID:** `I5.T4`
        *   **Description:** Implement the functionality to fetch the list of available models from OpenRouter using the `OpenRouterClient`. The UI should trigger this fetch, and the service worker will return the list to populate the model combobox.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 14.4 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/openRouterClient.ts`, `src/ui/components/AiSettings.tsx`]
        *   **Target Files:** [`src/background/services/openRouterClient.ts`, `src/ui/components/AiSettings.tsx`]
        *   **Deliverables:** A populated model selection dropdown in the UI.
        *   **Acceptance Criteria:** When a valid API key is entered, the model combobox is populated with models fetched from the OpenRouter API.
        *   **Dependencies:** `I5.T3`
        *   **Parallelizable:** No

---

### Iteration 6: Core Action Pipeline (Like & AI Reply)

*   **Iteration ID:** `I6`
*   **Goal:** Implement the main automation pipeline for liking and replying to comments using the configured AI.
*   **Prerequisites:** `I5`
*   **Tasks:**
    *   **Task 6.1:**
        *   **Task ID:** `I6.T1`
        *   **Description:** Implement the `PipelineManager` in the service worker. This will manage the Finite State Machine (FSM) for each comment (`QUEUED` -> `LIKED` -> `REPLIED` -> ...). Implement the Start/Stop/Resume logic that controls the pipeline execution.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 9 and 21 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/pipelineManager.ts`]
        *   **Target Files:** [`src/background/services/pipelineManager.ts`]
        *   **Deliverables:** A state machine and controller for the automation pipeline.
        *   **Acceptance Criteria:** The Start button initiates the processing loop, and the Stop button gracefully pauses it.
        *   **Dependencies:** `I4.T1`
        *   **Parallelizable:** No
    *   **Task 6.2:**
        *   **Task ID:** `I6.T2`
        *   **Description:** Implement the "Like" action in `domInteractor.ts`, controlled by a message from the `PipelineManager`. The pipeline will issue a "like" command for a specific comment, and the content script will find and click the corresponding button.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 7 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/content-scripts/domInteractor.ts`]
        *   **Target Files:** [`src/content-scripts/domInteractor.ts`]
        *   **Deliverables:** A function to perform the "Like" action.
        *   **Acceptance Criteria:** The extension successfully likes a target comment on the page.
        *   **Dependencies:** `I6.T1`
        *   **Parallelizable:** No
    *   **Task 6.3:**
        *   **Task ID:** `I6.T3`
        *   **Description:** Integrate the `OpenRouterClient` with the `PipelineManager`. When a comment is ready for a reply, the manager will construct the prompt using the templates and settings, call the chat completions endpoint, and receive the AI-generated text.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 14.5 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/pipelineManager.ts`, `src/background/services/openRouterClient.ts`]
        *   **Target Files:** [`src/background/services/pipelineManager.ts`]
        *   **Deliverables:** Logic to generate a reply for a given comment.
        *   **Acceptance Criteria:** The pipeline successfully gets a valid reply string from the OpenRouter API. It correctly handles the `__SKIP__` response.
        *   **Dependencies:** `I5.T3`, `I6.T1`
        *   **Parallelizable:** No
    *   **Task 6.4:**
        *   **Task ID:** `I6.T4`
        *   **Description:** Implement the "Reply" action in `domInteractor.ts`. This function will receive the AI-generated text, click the reply button, simulate human-like typing into the text box, and submit the reply.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 7 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/content-scripts/domInteractor.ts`]
        *   **Target Files:** [`src/content-scripts/domInteractor.ts`]
        *   **Deliverables:** A function to perform the "Reply" action.
        *   **Acceptance Criteria:** The extension successfully posts the AI-generated text as a reply to a target comment.
        *   **Dependencies:** `I6.3`
        *   **Parallelizable:** No
    *   **Task 6.5:**
        *   **Task ID:** `I6.T5`
        *   **Description:** Implement the real-time "Pipeline Progress" view in the UI. This will be a list of comments being processed, with a stepper for each row showing the current state (Queued → Liked → Replied).
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 0 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/ui/components/PipelineProgress.tsx`, `src/ui/store/index.ts`]
        *   **Target Files:** [`src/ui/components/PipelineProgress.tsx`]
        *   **Deliverables:** A dynamic UI component showing real-time progress.
        *   **Acceptance Criteria:** As the pipeline runs, the UI accurately reflects the status of each comment with animated step transitions.
        *   **Dependencies:** `I4.T2`, `I6.1`
        *   **Parallelizable:** No

---

### Iteration 7: Advanced Actions (Connection Status & DM)

*   **Iteration ID:** `I7`
*   **Goal:** Add the functionality to check a commenter's connection status and send AI-generated direct messages.
*   **Prerequisites:** `I6`
*   **Tasks:**
    *   **Task 7.1:**
        *   **Task ID:** `I7.T1`
        *   **Description:** Implement the logic to check connection status. The pipeline will open a commenter's profile in a new, background tab, parse the DOM to determine if they are a connection, and then close the tab. The result is saved to the state file.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 6 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/pipelineManager.ts`]
        *   **Target Files:** [`src/background/services/pipelineManager.ts`]
        *   **Deliverables:** Logic to determine and persist connection status.
        *   **Acceptance Criteria:** The `connected` field in the comment's state is correctly updated to `true` or `false`.
        *   **Dependencies:** `I6.T1`
        *   **Parallelizable:** No
    *   **Task 7.2:**
        *   **Task ID:** `I7.T2`
        *   **Description:** Implement the "Send DM" action. This includes generating the DM text via OpenRouter (using the DM prompt), opening the messaging thread URL, typing the message, and sending it.
        *   **Agent Type Hint:** `BackendAgent`, `FrontendAgent`
        *   **Inputs:** Section 8 and 14.6 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/pipelineManager.ts`, `src/content-scripts/domInteractor.ts`]
        *   **Target Files:** [`src/background/services/pipelineManager.ts`, `src/content-scripts/domInteractor.ts`]
        *   **Deliverables:** A complete DM sending functionality integrated into the pipeline.
        *   **Acceptance Criteria:** For a connected commenter, the extension successfully sends a personalized DM.
        *   **Dependencies:** `I7.T1`
        *   **Parallelizable:** No

---

### Iteration 8: Logging, Error Handling & Polish

*   **Iteration ID:** `I8`
*   **Goal:** Implement robust logging, comprehensive error handling with retries, and final UI/UX polish.
*   **Prerequisites:** `I7`
*   **Tasks:**
    *   **Task 8.1:**
        *   **Task ID:** `I8.T1`
        *   **Description:** Implement a structured logger in the service worker. All significant events (pipeline steps, API calls, errors) should generate a structured log object. These logs should be broadcast to the UI.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 12 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/logger.ts`]
        *   **Target Files:** [`src/background/logger.ts`]
        *   **Deliverables:** A structured logging service.
        *   **Acceptance Criteria:** The service worker generates detailed, structured logs for all key operations.
        *   **Dependencies:** `I6.T1`
        *   **Parallelizable:** No
    *   **Task 8.2:**
        *   **Task ID:** `I8.T2`
        *   **Description:** Build the live "Logs Panel" in the UI. It should display a stream of incoming log messages and include controls for filtering by log level (Info, Warn, Error).
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** `I8.T1` deliverables.
        *   **Input Files**: (Array of Strings) [`src/ui/components/LogsPanel.tsx`, `src/ui/store/index.ts`]
        *   **Target Files:** [`src/ui/components/LogsPanel.tsx`]
        *   **Deliverables:** A functional logging UI.
        *   **Acceptance Criteria:** The Logs Panel displays logs in real-time and can be filtered correctly.
        *   **Dependencies:** `I8.T1`
        *   **Parallelizable:** No
    *   **Task 8.3:**
        *   **Task ID:** `I8.T3`
        *   **Description:** Implement the retry logic with exponential backoff and jitter for all external network requests and critical DOM actions, as specified in Section 10 of the requirements. Update the state with attempt counts and final error messages.
        *   **Agent Type Hint:** `BackendAgent`
        *   **Inputs:** Section 10 of the requirements.
        *   **Input Files**: (Array of Strings) [`src/background/services/pipelineManager.ts`, `src/background/services/openRouterClient.ts`]
        *   **Target Files:** [`src/background/services/pipelineManager.ts`, `src/background/services/openRouterClient.ts`]
        *   **Deliverables:** Robust retry mechanisms.
        *   **Acceptance Criteria:** A failed API call is retried up to 3 times with increasing delays. A final failure updates the comment's status to "FAILED" and logs the error.
        *   **Dependencies:** `I8.T1`
        *   **Parallelizable:** No
    *   **Task 8.4:**
        *   **Task ID:** `I8.T4`
        *   **Description:** Add final UI polish. Implement skeleton loaders for when data is being fetched, add smooth transitions for counter updates, and ensure the UI is fully responsive and non-blocking.
        *   **Agent Type Hint:** `FrontendAgent`
        *   **Inputs:** Section 0 "UX Notes" of the requirements.
        *   **Input Files**: (Array of Strings) [`src/ui/`]
        *   **Target Files:** [`src/ui/App.tsx` and various components]
        *   **Deliverables:** A polished and professional-looking user interface.
        *   **Acceptance Criteria:** The UI feels smooth, responsive, and provides clear visual feedback during operations.
        *   **Dependencies:** `I8.T2`
        *   **Parallelizable:** No

## 5. Verification and Integration Strategy

*   **Testing Levels:**
    *   **Unit Tests:** Jest or Vitest will be used to test pure logic within the service worker, such as state transformations, FSM logic, and utility functions.
    *   **Component Tests:** Preact components will be tested using Testing Library to verify rendering and user interactions in isolation.
    *   **End-to-End (E2E) Tests:** Manual E2E testing will be performed in a browser with the extension loaded to verify complete workflows. Automated E2E testing with a framework like Playwright is a future consideration.
*   **CI/CD:** A GitHub Actions workflow will be established to run on every push/PR. It will perform:
    1.  Dependency Installation (`npm ci`)
    2.  Linting (`npm run lint`)
    3.  Unit & Component Tests (`npm run test`)
    4.  Type Checking (`npm run typecheck`)
    5.  Production Build (`npm run build`)
    6.  PlantUML syntax validation for all `.puml` files.
*   **Code Quality Gates:** PRs must pass all CI checks before being merged. A code coverage threshold (e.g., 70% for unit tests) will be enforced.
*   **Artifact Validation:** PlantUML files will be automatically checked for syntax errors in the CI pipeline. JSON Schema files will be validated against the meta-schema.

## 6. Glossary

*   **DOM:** Document Object Model. The programmatic interface for a web page's structure.
*   **FSM:** Finite State Machine. A model used to manage the state of each comment as it moves through the processing pipeline (e.g., QUEUED, LIKED, FAILED).
*   **Jitter:** Intentional random variation added to delays to make automated actions appear less robotic and more human-like.
*   **Manifest V3:** The current standard for Chrome extensions, which mandates a Service Worker for background logic.
*   **OpenRouter:** An external API service that provides a unified interface to various Large Language Models (LLMs).
*   **URN:** Uniform Resource Name. A unique identifier used by LinkedIn for entities like posts.