# System Architecture Blueprint: LinkedIn Engagement Assistant

**Version:** 1.0
**Date:** 2023-10-27
**Generated By:** Expert AI System Architect

## 1. Introduction & Goals

*   **1.1. Project Vision:** To create an intelligent browser extension that automates and scales a user's engagement on LinkedIn. The system acts as a personal assistant, intelligently liking, replying to, and messaging commenters on a given post, using AI to generate human-like, personalized content.

*   **1.2. Key Objectives:**
    *   **Automation:** Automate the repetitive tasks of liking, replying, and sending direct messages on LinkedIn posts.
    *   **Intelligence:** Leverage AI via OpenRouter to generate context-aware, high-quality replies and DMs based on user-defined prompts.
    *   **Control & Visibility:** Provide a real-time, non-intrusive sidebar UI for monitoring progress, viewing logs, and controlling the automation pipeline (start, stop, resume).
    *   **Resilience:** Ensure robust operation through state persistence, allowing the system to recover and resume from crashes or interruptions.
    *   **Safety:** Simulate human behavior through configurable delays, rate limits, and jitter to minimize the risk of detection and account flagging.
    *   **Configurability:** Allow users to fully configure AI models, prompts, and operational parameters to match their personal tone and strategy.

*   **1.3. Scope:**
    *   **In Scope:** The system is a browser extension for Chromium-based browsers (Manifest V3). It operates exclusively on the `linkedin.com` domain. All logic and data storage are client-side, within the user's browser. The system interacts with one external service: the OpenRouter API.
    *   **Out of Scope:** This blueprint does not cover a centralized backend server, user account management outside of LinkedIn, or a multi-user SaaS platform. It does not support browsers other than those compatible with Manifest V3.

*   **1.4. Key Assumptions:**
    *   The user has an active, authenticated session on LinkedIn.
    *   The user will provide a valid API key for the OpenRouter service.
    *   LinkedIn's front-end DOM structure and API endpoints are relatively stable. The architecture must, however, be modular enough to accommodate changes.
    *   The user understands and accepts the risks associated with using automation tools on social media platforms, as outlined in their Terms of Service.

## 2. Architectural Drivers

*   **2.1. Functional Requirements Summary:** The system must perform DOM scraping to extract post and comment data, manage a sequential processing pipeline (Like -> Reply -> DM) for each targeted comment, interact with the OpenRouter API for content generation, persist state to local storage for recovery, and present a comprehensive control and monitoring UI.

*   **2.2. Non-Functional Requirements (NFRs):**
    *   **Usability:** The UI must be non-blocking to the user's normal browsing on LinkedIn. It should be intuitive, responsive, and provide clear, real-time feedback.
    *   **Reliability:** The system must be fault-tolerant. Operations must be idempotent and resumable. Failures in one step (e.g., an AI call) should be handled gracefully with retries and clear error logging, without halting the entire process.
    *   **Performance:** DOM interactions and background processing should be efficient to avoid freezing the browser tab. UI updates should be smooth.
    *   **Security:** The user's OpenRouter API key is sensitive and must be stored securely within the browser's storage, masked in the UI, and never included in logs.
    *   **Maintainability:** DOM selectors and AI prompt templates should be centralized and easily configurable to adapt to changes in LinkedIn's UI or user strategy. The codebase should be modular.

*   **2.3. Constraints & Preferences:**
    *   **Technology Constraint:** Must be a browser extension compliant with Manifest V3. This dictates the use of a Service Worker for background tasks and limits certain DOM access patterns.
    *   **Platform Constraint:** The system is tightly coupled to the LinkedIn web application and the OpenRouter API.
    *   **User Preference:** The requirements emphasize a "pro modern" UI, human-like automation behavior, and detailed observability through logs and live counters.

## 3. Proposed Architecture

*   **3.1. Architectural Style:**
    **Client-Side, Event-Driven Architecture.** The system is entirely self-contained within the browser extension. It does not rely on a dedicated backend server. Its components (Service Worker, Content Scripts, UI) are decoupled and communicate asynchronously via an event-driven messaging pattern (`chrome.runtime.sendMessage`). This style is ideal for a browser extension, as it aligns with the Manifest V3 model, promotes resilience, and keeps all user data on the client machine.

*   **3.2. Technology Stack Summary:**

| Category          | Technology                                                              | Justification                                                                                                                              |
| ----------------- | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Frontend UI**       | **Preact / TypeScript**                                                 | Preact provides a lightweight, fast, and component-based UI library, ideal for an embedded sidebar. TypeScript adds crucial type safety. |
| **Styling**         | **Shadow DOM + CSS Modules/Tailwind**                                   | Shadow DOM encapsulates styles to prevent conflicts with LinkedIn's CSS. CSS Modules or Tailwind provide a structured styling approach. |
| **State Management**  | **Zustand / Jotai** (for UI)                                            | Lightweight state management libraries that integrate well with Preact for managing the complex UI state (counters, logs, settings).     |
| **"Backend" Logic** | **Service Worker (Manifest V3)**                                        | The persistent background component required by Manifest V3. It will host the core orchestration, state management, and API logic.       |
| **Data Storage**    | **`chrome.storage.local` & `chrome.storage.sync`**                      | `local` is used for larger, per-post state JSON files. `sync` is used for user settings (like AI config) to be synced across devices. |
| **Key Libraries**   | **DOMPurify**                                                           | To sanitize any data before rendering it in the UI, preventing XSS vulnerabilities.                                                         |
| **Build Tools**     | **Vite / Webpack**                                                      | Modern build tools to handle TypeScript compilation, bundling, and asset management for the extension.                                     |

*   **3.3. System Context Diagram (C4 Level 1):**
    *   **Description:** This diagram shows the LinkedIn Engagement Assistant as a single system operating within the user's browser. It illustrates its interactions with the User, the LinkedIn Web Application, and the external OpenRouter AI service.
    *   **Diagram (PlantUML):**
        ~~~plantuml
        @startuml
        !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

        title System Context Diagram for LinkedIn Engagement Assistant

        Person(user, "LinkedIn User", "The user who installs and operates the extension.")
        System(linkedin, "LinkedIn Web App", "The platform where the extension operates, providing post and comment data.")
        System_Ext(openrouter, "OpenRouter AI", "External AI service used to generate replies and DMs via its API.")

        System_Boundary(ext_boundary, "LinkedIn Engagement Assistant") {
            System(extension, "Browser Extension", "Automates engagement by orchestrating DOM interactions and AI content generation.")
        }

        Rel(user, extension, "Configures, controls, and monitors", "GUI / Sidebar")
        Rel(extension, linkedin, "Reads post/comment data and performs actions (like, reply, DM)", "Browser DOM APIs")
        Rel(extension, openrouter, "Requests AI-generated text for replies and DMs", "HTTPS/JSON API")
        @enduml
        ~~~

*   **3.4. Container Diagram (C4 Level 2):**
    *   **Description:** This diagram zooms into the "LinkedIn Engagement Assistant" system boundary, breaking it down into its major logical components (containers). It shows how these components interact to deliver the extension's functionality.
    *   **Diagram (PlantUML):**
        ~~~plantuml
        @startuml
        !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

        title Container Diagram for LinkedIn Engagement Assistant

        Person(user, "LinkedIn User", "Operates the extension.")
        System(linkedin, "LinkedIn Web App", "The host web application.")
        System_Ext(openrouter, "OpenRouter AI", "External AI service.")

        System_Boundary(ext_boundary, "LinkedIn Engagement Assistant") {
            Container(sidebar_ui, "Sidebar UI", "Preact/TS, Shadow DOM", "The user-facing interface for control, configuration, and monitoring. Injected into the LinkedIn page.")
            Container(dom_interactor, "DOM Interactor", "TypeScript, Web APIs", "A content script responsible for all direct DOM manipulation: scrolling, parsing selectors, clicking buttons, and typing text.")
            Container(orchestrator, "Orchestration Service", "Service Worker (JS/TS)", "The core background process. Manages the state machine, processing pipeline, API calls, and persistence.")
            ContainerDb(storage, "Browser Storage", "Chrome Storage API", "Stores user configuration (sync) and per-post processing state (local).")
        }

        Rel(user, sidebar_ui, "Uses")
        Rel(sidebar_ui, orchestrator, "Sends commands (Start/Stop) and receives real-time updates (logs, counts)", "chrome.runtime messages")

        Rel(orchestrator, dom_interactor, "Issues commands (e.g., 'scroll', 'get_comment_text', 'click_like')", "chrome.tabs messages")
        Rel_Back(orchestrator, dom_interactor, "Receives results from DOM operations")

        Rel(dom_interactor, linkedin, "Reads from and writes to", "DOM API")

        Rel(orchestrator, storage, "Reads/Writes", "chrome.storage API")
        Rel(orchestrator, openrouter, "Fetches models and generates text", "HTTPS/JSON API")
        @enduml
        ~~~

*   **3.5. Component Diagram (for Orchestration Service):**
    *   **Description:** This diagram provides a more detailed view of the `Orchestration Service` container, which runs in the Service Worker. It shows the key internal components responsible for managing the extension's logic.
    *   **Diagram (PlantUML):**
        ~~~plantuml
        @startuml
        !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

        title Component Diagram for Orchestration Service

        Container(orchestrator, "Orchestration Service", "Service Worker (JS/TS)") {
            Component(msg_router, "Message Router", "JS/TS Module", "Receives and routes incoming messages from the UI and other components.")
            Component(pipeline_manager, "Pipeline Manager", "JS/TS Module", "Manages the state machine (FSM) for each comment (Queued -> Liked -> ...). Orchestrates the sequence of actions.")
            Component(state_manager, "State Manager", "JS/TS Module", "Handles all reads and writes of per-post state to/from Browser Storage. Ensures data integrity.")
            Component(config_manager, "Configuration Manager", "JS/TS Module", "Manages user settings (AI config, delays, limits) from Browser Storage.")
            Component(openrouter_client, "OpenRouter Client", "JS/TS Module", "Encapsulates all communication with the OpenRouter API, including authentication, retries, and error handling.")
            Component(logger, "Structured Logger", "JS/TS Module", "Generates structured log events and broadcasts them to the UI.")
        }

        ' External dependencies (defined in other diagrams)
        System_Ext(openrouter, "OpenRouter AI")
        ContainerDb(storage, "Browser Storage")
        Container(sidebar_ui, "Sidebar UI")

        Rel(msg_router, pipeline_manager, "Triggers pipeline actions (start, stop)")
        Rel(msg_router, config_manager, "Handles config updates")
        Rel(msg_router, logger, "Receives log requests")

        Rel(pipeline_manager, state_manager, "Uses to persist progress")
        Rel(pipeline_manager, config_manager, "Uses to get delays and limits")
        Rel(pipeline_manager, openrouter_client, "Uses to generate replies/DMs")
        Rel(pipeline_manager, logger, "Sends logs about pipeline steps")

        Rel(state_manager, storage, "Reads/Writes state JSON")
        Rel(config_manager, storage, "Reads/Writes config JSON")

        Rel(openrouter_client, openrouter, "Makes API calls", "HTTPS")

        Rel(logger, sidebar_ui, "Broadcasts log events to", "chrome.runtime messages")
        @enduml
        ~~~

*   **3.6. Data Model Overview & ERD:**
    *   **Description:** The system does not use a traditional relational database. Instead, it persists state in JSON format within the browser's local storage. The primary data structure is a JSON file for each LinkedIn post being processed. This diagram illustrates the schema of that JSON file.
    *   **Key Entities:** `Post`, `Comment`. A `Post` is the root object which contains metadata and an array of `Comment` objects.
    *   **Diagram (PlantUML - ERD-like representation of JSON Schema):**
        ~~~plantuml
        @startuml
        title Data Schema for Per-Post State JSON

        entity Post {
          *postId (URN) : string <<PK>>
          --
          postUrl : string
          lastUpdated : timestamp
          runState : enum ('idle', 'running', 'paused', 'error')
        }

        entity Comment {
          *commentId : string <<PK>>
          --
          text : string
          ownerProfileUrl : string
          timestamp : string
          type : enum ('top-level', 'reply')
          connected : boolean
          threadId : string
          likeStatus : enum ('', 'DONE', 'FAILED')
          replyStatus : enum ('', 'DONE', 'FAILED')
          dmStatus : enum ('', 'DONE', 'FAILED')
          lastError : string
        }

        entity Attempts {
          like : integer
          reply : integer
          dm : integer
        }

        entity PipelineTimestamps {
          queuedAt : timestamp
          likedAt : timestamp
          repliedAt : timestamp
          dmAt : timestamp
        }

        Post ||--o{ Comment : contains
        Comment ||--|{ Attempts : has
        Comment ||--|{ PipelineTimestamps : has

        @enduml
        ~~~

*   **3.7. API Design & Communication:**
    *   **API Style:** The system consumes an external **RESTful API** (OpenRouter), which is OpenAI-compatible. Internal communication is **Asynchronous Messaging** using the `chrome.runtime` and `chrome.tabs` APIs.
    *   **Communication Patterns:**
        *   **UI -> Service Worker:** Asynchronous commands (e.g., `START_PIPELINE`, `UPDATE_CONFIG`).
        *   **Service Worker -> UI:** Asynchronous events/updates (e.g., `STATE_UPDATED`, `NEW_LOG_ENTRY`).
        *   **Service Worker -> Content Script:** Asynchronous commands (e.g., `CLICK_ELEMENT`, `GET_TEXT`).
        *   **Content Script -> Service Worker:** Asynchronous responses with data from the DOM.
    *   **Key Interaction Flow (Sequence Diagram):**
        *   **Description:** This diagram illustrates the sequence of events when a user starts the automation pipeline on a LinkedIn post.
        *   **Diagram (PlantUML):**
            ~~~plantuml
            @startuml
            title Sequence Diagram: Start Processing a Post

            actor User
            participant "Sidebar UI" as UI
            participant "Orchestration\nService" as ServiceWorker
            participant "DOM Interactor" as ContentScript
            database "Browser Storage" as Storage
            participant "OpenRouter API" as API

            User -> UI : Clicks "Start"
            UI -> ServiceWorker : sendMessage({ type: 'START_PIPELINE', postId: '...' })

            ServiceWorker -> Storage : Load state for postId
            Storage --> ServiceWorker : Returns existing or new state JSON

            ServiceWorker -> ServiceWorker : Identify next comment to process
            ServiceWorker -> ContentScript : sendMessage({ type: 'CLICK_LIKE', commentId: '...' })
            ContentScript -> ContentScript : Finds and clicks Like button
            ContentScript --> ServiceWorker : Response({ success: true })

            ServiceWorker -> Storage : Update comment likeStatus to 'DONE'
            ServiceWorker -> UI : sendMessage({ type: 'STATE_UPDATE', ... })

            ServiceWorker -> ContentScript : sendMessage({ type: 'GET_COMMENT_TEXT', commentId: '...' })
            ContentScript --> ServiceWorker : Response({ text: '...' })

            ServiceWorker -> API : POST /chat/completions (with comment text)
            API --> ServiceWorker : AI-generated reply text

            ServiceWorker -> ContentScript : sendMessage({ type: 'SUBMIT_REPLY', commentId: '...', text: '...' })
            ContentScript -> ContentScript : Types and submits reply
            ContentScript --> ServiceWorker : Response({ success: true })

            ServiceWorker -> Storage : Update comment replyStatus to 'DONE'
            ServiceWorker -> UI : sendMessage({ type: 'STATE_UPDATE', ... })
            UI -> User : Updates progress stepper for comment
            @enduml
            ~~~

*   **3.8. Cross-Cutting Concerns:**
    *   **Authentication & Authorization:** The system relies on the user's existing authenticated LinkedIn session. For the OpenRouter API, the user's API key is stored in `chrome.storage.sync`, retrieved by the Service Worker, and sent as a `Bearer` token in the `Authorization` header for each request.
    *   **Logging & Monitoring:** The Service Worker's Structured Logger generates timestamped log objects with levels (Info, Warn, Error) and context. These are sent via messages to the Sidebar UI, which maintains a filterable, auto-scrolling log panel. Logs can be exported as NDJSON.
    *   **Security Considerations:**
        *   **API Key Storage:** The API key is stored using `chrome.storage.sync`. While not encrypted by default, it is not accessible by other websites. A UI notice will inform the user it's stored locally.
        *   **DOM Interaction:** All interactions are performed via content scripts, respecting the extension sandbox.
        *   **Input Sanitization:** User-provided custom prompts will be treated as plain text. Any data rendered in the UI will be sanitized to prevent XSS.
    *   **Scalability & Performance:**
        *   **Scalability:** The system is single-user and scales with the performance of the user's machine. The "Max Open Tabs" setting prevents overwhelming the system with too many concurrent profile-scraping tasks.
        *   **Performance:** DOM queries are optimized to be specific. The UI uses a virtualized list for the pipeline progress and logs to handle thousands of entries without performance degradation. Background tasks are managed sequentially to avoid overwhelming LinkedIn's servers.
    *   **Reliability & Availability:**
        *   **Fault Tolerance:** The per-post JSON state file is the source of truth. If the browser or tab crashes, the pipeline can be resumed from the last successfully completed step for each comment upon reload.
        *   **Retries:** All external API calls (OpenRouter) and critical DOM actions (clicks, submissions) will implement a retry mechanism with exponential backoff and jitter.
        *   **Idempotency:** Before performing an action (e.g., liking), the system will check the DOM to see if the action has already been completed, preventing duplicate operations on resume.

*   **3.9. Deployment View:**
    *   **Target Environment:** User's local Chromium-based browser (e.g., Google Chrome, Microsoft Edge).
    *   **Deployment Strategy:** The extension is packaged into a `.zip` or `.crx` file. It will be deployed and distributed via the official Chrome Web Store (or equivalent for other browsers), which handles review, hosting, and updates.

## 4. Design Rationale & Trade-offs

*   **4.1. Key Decisions Summary:**
    *   **Service Worker as Central Orchestrator:** Chosen for its persistence and alignment with Manifest V3, making it the reliable core for managing state and long-running tasks.
    *   **Per-Post JSON State Files:** A simple and robust method for state persistence and recovery. It also allows for easy data export and debugging.
    *   **Asynchronous Messaging:** Decouples the UI, background logic, and DOM interaction, improving resilience and responsiveness.
    *   **Client-Side Only Architecture:** Simplifies deployment, enhances user privacy (all data stays local), and eliminates server costs and maintenance.

*   **4.2. Alternatives Considered:**
    *   **IndexedDB for Storage:** Instead of JSON files in `chrome.storage`, IndexedDB was considered. It offers better performance for querying large datasets. **Reason for Rejection:** It adds significant complexity (transactions, schema versioning) which is not justified for the current scope. The JSON file approach is simpler to implement and debug.
    *   **Centralized Backend Server:** A backend could manage state and AI calls. **Reason for Rejection:** This would introduce server costs, complexity, and major privacy concerns, as user data and LinkedIn session information would need to be sent to a server. The client-side approach is more aligned with a lightweight "assistant" tool.

*   **4.3. Known Risks & Mitigation:**
    *   **Risk:** LinkedIn changes its website's DOM structure, breaking the extension's selectors.
        *   **Mitigation:** All CSS selectors will be stored in a centralized configuration file, making them easy to update and deploy without changing the core logic.
    *   **Risk:** The user's LinkedIn account is flagged or restricted due to automation.
        *   **Mitigation:** The architecture explicitly includes features to mimic human behavior: configurable random delays (jitter), rate limits (max replies per session), and clear warnings to the user about the risks.
    *   **Risk:** The OpenRouter API is unavailable or returns errors.
        *   **Mitigation:** The OpenRouter client will have built-in retry logic with exponential backoff. The UI will clearly indicate when the AI service is degraded or unavailable.

## 5. Future Considerations

*   **5.1. Potential Evolution:**
    *   **Multi-Platform Support:** The core orchestration logic could be abstracted to support other platforms like Twitter/X by creating new, platform-specific "DOM Interactor" modules.
    *   **Advanced Analytics:** A dashboard could be added to the sidebar to show historical engagement statistics (e.g., replies sent per day, success rates).
    *   **Batch Processing:** Introduce a feature to queue up multiple post URLs for sequential processing.

*   **5.2. Areas for Deeper Dive:**
    *   **Selector Strategy:** A detailed analysis of LinkedIn's DOM is needed to find the most stable and reliable selectors for all required elements.
    *   **UI/UX Design:** A high-fidelity design for the sidebar UI to ensure it meets the "pro modern" and usability requirements.
    *   **Error Taxonomy:** A comprehensive list of potential failure modes (DOM, network, API) and the desired recovery behavior for each.

## 6. Glossary

*   **DOM:** Document Object Model. The tree-like structure of an HTML page that the extension interacts with.
*   **FSM:** Finite State Machine. A model used to manage the state of each comment as it moves through the processing pipeline.
*   **Idempotent:** An operation that can be applied multiple times without changing the result beyond the initial application.
*   **Jitter:** Intentional random variation added to delays to make automated actions appear less robotic.
*   **Manifest V3:** The current standard for Chrome extensions, which mandates the use of a Service Worker for background code.
*   **OpenRouter:** An external API service that provides access to various Large Language Models (LLMs).
*   **URN:** Uniform Resource Name. A unique identifier used by LinkedIn for entities like posts and comments.